/**
 * Format character description with structured sections
 * @param {Object} char - Character data from AI analysis
 * @param {boolean} isPersona - Whether this is being generated as a persona
 * @returns {string} Formatted description
 */
function formatCharacterDescription(char, isPersona = false) {
  let description = '';
  
  if (isPersona) {
    // For persona cards (playing AS this character)
    description += `### Background\n${char.background || ''}\n\n`;
    description += `### Physical Description\n${char.physicalDescription || ''}\n\n`;
    description += `### Personality Traits\n${char.personality || ''}\n\n`;
    
    if (char.scenario) {
      description += `### Scenario\n${char.scenario}\n\n`;
    }
    
    if (char.commonPhrases && char.commonPhrases.length > 0) {
      description += `### Common Phrases\n${char.commonPhrases.map(p => `- "${p}"`).join('\n')}\n\n`;
    }
    
    if (char.firstMessages && char.firstMessages.length > 0) {
      description += `### First Message Options\n`;
      char.firstMessages.forEach((msg, idx) => {
        description += `\n**Option ${idx + 1}:**\n${msg}\n`;
      });
      description += '\n';
    }
    
    if (char.exampleDialogue) {
      description += `### Example Text\n${char.exampleDialogue}`;
    }
  } else {
    // For regular character cards (interacting WITH this character)
    description += `### Background\n${char.background || ''}\n\n`;
    description += `### Physical Description\n${char.physicalDescription || ''}\n\n`;
    description += `### Personality Traits\n${char.personality || ''}\n\n`;
    
    if (char.scenario) {
      description += `### Scenario\n${char.scenario}\n\n`;
    }
    
    if (char.commonPhrases && char.commonPhrases.length > 0) {
      description += `### Common Phrases\n${char.commonPhrases.map(p => `- "${p}"`).join('\n')}\n\n`;
    }
    
    if (char.firstMessages && char.firstMessages.length > 0) {
      description += `### First Message Options\n`;
      char.firstMessages.forEach((msg, idx) => {
        description += `\n**Option ${idx + 1}:**\n${msg}\n`;
      });
      description += '\n';
    }
    
    if (char.exampleDialogue) {
      description += `### Example Text\n${char.exampleDialogue}`;
    }
  }
  
  return description.trim();
}

/**
 * Get display label for character role
 * @param {string} role - Character role from AI analysis
 * @returns {string} Display label
 */
function getRoleLabel(role) {
  const roleLabels = {
    'main_character': 'Main Character',
    'protagonist': 'Protagonist',
    'love_interest': 'Love Interest',
    'antagonist': 'Antagonist',
    'supporting': 'Supporting Character',
    'mentor': 'Mentor',
    'rival': 'Rival'
  };
  
  return roleLabels[role] || 'Character';
}

/**
 * Generate character cards from analyzed characters
 * @param {Array} characters - Array of character objects from AI analysis
 * @param {string} coverImageBase64 - Optional base64 encoded cover image
 * @returns {Array} Array of character cards (includes both regular and persona versions)
 */
export function generateCharacterCards(characters, coverImageBase64 = null) {
  const cards = [];
  
  characters.forEach(char => {
    // Build tag array from AI tags plus role
    const tags = [
      ...(char.tags || []),
      char.role || 'character'
    ];
    
    // Remove duplicates and convert to lowercase
    const uniqueTags = [...new Set(tags.map(t => t.toLowerCase()))];
    
    // Generate regular character card (for interacting WITH the character)
    const firstMessages = char.firstMessages || [char.firstMessage] || [`*${char.name} appears before you.*`];
    const regularCard = {
      spec: 'chara_card_v2',
      spec_version: '2.0',
      data: {
        name: char.name,
        description: formatCharacterDescription(char, false),
        personality: char.personality || '',
        scenario: char.scenario || '',
        first_mes: firstMessages[0] || `*${char.name} appears before you.*`,
        mes_example: char.exampleDialogue || '',
        creator_notes: 'Auto-generated by Chatbot Maker',
        system_prompt: '',
        post_history_instructions: '',
        tags: uniqueTags,
        creator: 'Chatbot Maker',
        character_version: 'main',
        alternate_greetings: firstMessages.slice(1), // Store other first messages as alternates
        extensions: {
          depth_prompt: {
            role: 'system',
            depth: 4,
            prompt: ''
          }
        },
        character_book: null
      },
      characterType: getRoleLabel(char.role),
      isPersona: false,
      canBePersona: char.canBePersona || false
    };
    
    cards.push(regularCard);
    
    // If character can be a persona, generate persona version
    if (char.canBePersona) {
      const personaCard = {
        spec: 'chara_card_v2',
        spec_version: '2.0',
        data: {
          name: `${char.name} (Persona)`,
          description: formatCharacterDescription(char, true),
          personality: char.personality || '',
          scenario: char.scenario ? char.scenario.replace(/{{user}}/g, char.name) : '',
          first_mes: `*You are ${char.name}. Begin your story.*`,
          mes_example: char.exampleDialogue || '',
          creator_notes: 'Auto-generated by Chatbot Maker - Persona Version (roleplay AS this character)',
          system_prompt: `You are roleplaying as ${char.name}. Stay in character and respond as they would.`,
          post_history_instructions: '',
          tags: [...uniqueTags, 'persona'],
          creator: 'Chatbot Maker',
          character_version: 'persona',
          alternate_greetings: [],
          extensions: {
            depth_prompt: {
              role: 'system',
              depth: 4,
              prompt: `You are ${char.name}. Respond in their voice and style.`
            }
          },
          character_book: null
        },
        characterType: `${getRoleLabel(char.role)} (Persona)`,
        isPersona: true,
        canBePersona: false
      };
      
      cards.push(personaCard);
    }
  });
  
  return cards;
}

/**
 * Generate lorebook from world info
 * @param {Object} worldInfo - World information object from AI analysis
 * @returns {Object} Formatted lorebook
 */
export function generateLorebook(worldInfo) {
  const entries = {};
  let entryId = 1;
  let displayIndex = 0;

  const createEntry = (name, keys, content, comment, order) => ({
    uid: entryId,
    key: keys,
    keysecondary: [],
    comment: comment,
    content: content,
    constant: false,
    selective: true,
    selectiveLogic: 0,
    order: order,
    position: 1,
    disable: false,
    addMemo: true,
    excludeRecursion: true,
    probability: 100,
    displayIndex: displayIndex++,
    useProbability: true,
    secondary_keys: [],
    keys: keys,
    id: entryId,
    priority: 10,
    insertion_order: order,
    enabled: true,
    name: name,
    extensions: {
      depth: 4,
      weight: 10,
      addMemo: true,
      displayIndex: displayIndex - 1,
      useProbability: true,
      characterFilter: null,
      excludeRecursion: true
    },
    case_sensitive: false,
    depth: 4,
    characterFilter: null
  });

  // Add setting as an entry
  if (worldInfo.setting) {
    entries[entryId] = createEntry(
      'World Setting',
      ['world', 'setting', 'place'],
      worldInfo.setting,
      'World Setting',
      100
    );
    entryId++;
  }

  // Add locations
  if (worldInfo.locations) {
    worldInfo.locations.forEach((location) => {
      entries[entryId] = createEntry(
        location.name,
        [location.name.toLowerCase(), location.name],
        location.description,
        'Location',
        100
      );
      entryId++;
    });
  }

  // Add factions
  if (worldInfo.factions) {
    worldInfo.factions.forEach((faction) => {
      entries[entryId] = createEntry(
        faction.name,
        [faction.name.toLowerCase(), faction.name],
        faction.description,
        'Faction/Group',
        100
      );
      entryId++;
    });
  }

  // Add items
  if (worldInfo.items) {
    worldInfo.items.forEach((item) => {
      entries[entryId] = createEntry(
        item.name,
        [item.name.toLowerCase(), item.name],
        item.description,
        'Item/Artifact',
        100
      );
      entryId++;
    });
  }

  // Add concepts
  if (worldInfo.concepts) {
    worldInfo.concepts.forEach((concept) => {
      entries[entryId] = createEntry(
        concept.name,
        [concept.name.toLowerCase(), concept.name],
        concept.description,
        'Concept',
        100
      );
      entryId++;
    });
  }

  return {
    name: 'Generated Lorebook',
    description: 'Auto-generated world information',
    is_creation: false,
    scan_depth: 4,
    token_budget: 512,
    recursive_scanning: false,
    extensions: {},
    entries: Object.values(entries) // Convert entries object to array for frontend
  };
}
